<?xml version="1.0" encoding="UTF-8"?>
<config xmlns="http://www.knime.org/2008/09/XMLConfig" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.knime.org/2008/09/XMLConfig http://www.knime.org/XMLConfig_2008_09.xsd" key="spec.xml">
<entry key="spec_name" type="xstring" value="default"/>
<entry key="number_columns" type="xint" value="14"/>
<config key="column_spec_0">
<entry key="column_name" type="xstring" value="ID"/>
<config key="element_names">
<entry key="array-size" type="xint" value="0"/>
</config>
<config key="column_type">
<entry key="cell_class" type="xstring" value="org.knime.core.data.def.StringCell"/>
</config>
<config key="column_domain">
<config key="possible_values">
<entry key="array-size" type="xint" value="42"/>
<config key="0">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="MATH-724"/>
</config>
</config>
<config key="1">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="MATH-723"/>
</config>
</config>
<config key="2">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="MATH-719"/>
</config>
</config>
<config key="3">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="MATH-692"/>
</config>
</config>
<config key="4">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="MATH-654"/>
</config>
</config>
<config key="5">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="MATH-640"/>
</config>
</config>
<config key="6">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="MATH-618"/>
</config>
</config>
<config key="7">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="MATH-588"/>
</config>
</config>
<config key="8">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="MATH-575"/>
</config>
</config>
<config key="9">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="MATH-555"/>
</config>
</config>
<config key="10">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="MATH-540"/>
</config>
</config>
<config key="11">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="MATH-506"/>
</config>
</config>
<config key="12">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="MATH-505"/>
</config>
</config>
<config key="13">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="MATH-484"/>
</config>
</config>
<config key="14">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="MATH-481"/>
</config>
</config>
<config key="15">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="MATH-465"/>
</config>
</config>
<config key="16">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="MATH-464"/>
</config>
</config>
<config key="17">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="MATH-453"/>
</config>
</config>
<config key="18">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="MATH-434"/>
</config>
</config>
<config key="19">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="MATH-429"/>
</config>
</config>
<config key="20">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="MATH-421"/>
</config>
</config>
<config key="21">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="MATH-414"/>
</config>
</config>
<config key="22">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="MATH-411"/>
</config>
</config>
<config key="23">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="MATH-409"/>
</config>
</config>
<config key="24">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="MATH-408"/>
</config>
</config>
<config key="25">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="MATH-407"/>
</config>
</config>
<config key="26">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="MATH-406"/>
</config>
</config>
<config key="27">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="MATH-405"/>
</config>
</config>
<config key="28">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="MATH-404"/>
</config>
</config>
<config key="29">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="MATH-395"/>
</config>
</config>
<config key="30">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="MATH-392"/>
</config>
</config>
<config key="31">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="MATH-391"/>
</config>
</config>
<config key="32">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="MATH-390"/>
</config>
</config>
<config key="33">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="MATH-380"/>
</config>
</config>
<config key="34">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="MATH-377"/>
</config>
</config>
<config key="35">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="MATH-373"/>
</config>
</config>
<config key="36">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="MATH-369"/>
</config>
</config>
<config key="37">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="MATH-368"/>
</config>
</config>
<config key="38">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="MATH-367"/>
</config>
</config>
<config key="39">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="MATH-365"/>
</config>
</config>
<config key="40">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="MATH-362"/>
</config>
</config>
<config key="41">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="MATH-288"/>
</config>
</config>
</config>
</config>
<config key="column_properties"/>
</config>
<config key="column_spec_1">
<entry key="column_name" type="xstring" value="Created"/>
<config key="element_names">
<entry key="array-size" type="xint" value="0"/>
</config>
<config key="column_type">
<entry key="cell_class" type="xstring" value="org.knime.core.data.date.DateAndTimeCell"/>
</config>
<config key="column_domain">
<config key="lower_bound">
<entry key="datacell" type="xstring" value="org.knime.core.data.date.DateAndTimeCell"/>
<config key="org.knime.core.data.date.DateAndTimeCell">
<entry key="hasDate" type="xboolean" value="true"/>
<entry key="hasTime" type="xboolean" value="true"/>
<entry key="hasMillis" type="xboolean" value="true"/>
<entry key="timeInMillis" type="xlong" value="1251153071000"/>
</config>
</config>
<config key="upper_bound">
<entry key="datacell" type="xstring" value="org.knime.core.data.date.DateAndTimeCell"/>
<config key="org.knime.core.data.date.DateAndTimeCell">
<entry key="hasDate" type="xboolean" value="true"/>
<entry key="hasTime" type="xboolean" value="true"/>
<entry key="hasMillis" type="xboolean" value="true"/>
<entry key="timeInMillis" type="xlong" value="1323702221000"/>
</config>
</config>
</config>
<config key="column_properties"/>
</config>
<config key="column_spec_2">
<entry key="column_name" type="xstring" value="Resolved"/>
<config key="element_names">
<entry key="array-size" type="xint" value="0"/>
</config>
<config key="column_type">
<entry key="cell_class" type="xstring" value="org.knime.core.data.date.DateAndTimeCell"/>
</config>
<config key="column_domain">
<config key="lower_bound">
<entry key="datacell" type="xstring" value="org.knime.core.data.date.DateAndTimeCell"/>
<config key="org.knime.core.data.date.DateAndTimeCell">
<entry key="hasDate" type="xboolean" value="true"/>
<entry key="hasTime" type="xboolean" value="true"/>
<entry key="hasMillis" type="xboolean" value="true"/>
<entry key="timeInMillis" type="xlong" value="1251223808000"/>
</config>
</config>
<config key="upper_bound">
<entry key="datacell" type="xstring" value="org.knime.core.data.date.DateAndTimeCell"/>
<config key="org.knime.core.data.date.DateAndTimeCell">
<entry key="hasDate" type="xboolean" value="true"/>
<entry key="hasTime" type="xboolean" value="true"/>
<entry key="hasMillis" type="xboolean" value="true"/>
<entry key="timeInMillis" type="xlong" value="1328471690000"/>
</config>
</config>
</config>
<config key="column_properties"/>
</config>
<config key="column_spec_3">
<entry key="column_name" type="xstring" value="Updated"/>
<config key="element_names">
<entry key="array-size" type="xint" value="0"/>
</config>
<config key="column_type">
<entry key="cell_class" type="xstring" value="org.knime.core.data.date.DateAndTimeCell"/>
</config>
<config key="column_domain">
<config key="lower_bound">
<entry key="datacell" type="xstring" value="org.knime.core.data.date.DateAndTimeCell"/>
<config key="org.knime.core.data.date.DateAndTimeCell">
<entry key="hasDate" type="xboolean" value="true"/>
<entry key="hasTime" type="xboolean" value="true"/>
<entry key="hasMillis" type="xboolean" value="true"/>
<entry key="timeInMillis" type="xlong" value="1271205017000"/>
</config>
</config>
<config key="upper_bound">
<entry key="datacell" type="xstring" value="org.knime.core.data.date.DateAndTimeCell"/>
<config key="org.knime.core.data.date.DateAndTimeCell">
<entry key="hasDate" type="xboolean" value="true"/>
<entry key="hasTime" type="xboolean" value="true"/>
<entry key="hasMillis" type="xboolean" value="true"/>
<entry key="timeInMillis" type="xlong" value="1332605824000"/>
</config>
</config>
</config>
<config key="column_properties"/>
</config>
<config key="column_spec_4">
<entry key="column_name" type="xstring" value="Status"/>
<config key="element_names">
<entry key="array-size" type="xint" value="0"/>
</config>
<config key="column_type">
<entry key="cell_class" type="xstring" value="org.knime.core.data.def.StringCell"/>
</config>
<config key="column_domain">
<config key="possible_values">
<entry key="array-size" type="xint" value="1"/>
<config key="0">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="CLOSED"/>
</config>
</config>
</config>
</config>
<config key="column_properties"/>
</config>
<config key="column_spec_5">
<entry key="column_name" type="xstring" value="Type"/>
<config key="element_names">
<entry key="array-size" type="xint" value="0"/>
</config>
<config key="column_type">
<entry key="cell_class" type="xstring" value="org.knime.core.data.def.StringCell"/>
</config>
<config key="column_domain">
<config key="possible_values">
<entry key="array-size" type="xint" value="1"/>
<config key="0">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="BUG"/>
</config>
</config>
</config>
</config>
<config key="column_properties"/>
</config>
<config key="column_spec_6">
<entry key="column_name" type="xstring" value="Resolution"/>
<config key="element_names">
<entry key="array-size" type="xint" value="0"/>
</config>
<config key="column_type">
<entry key="cell_class" type="xstring" value="org.knime.core.data.def.StringCell"/>
</config>
<config key="column_domain">
<config key="possible_values">
<entry key="array-size" type="xint" value="2"/>
<config key="0">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="FIXED"/>
</config>
</config>
<config key="1">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="WONT_FIX"/>
</config>
</config>
</config>
</config>
<config key="column_properties"/>
</config>
<config key="column_spec_7">
<entry key="column_name" type="xstring" value="Version"/>
<config key="element_names">
<entry key="array-size" type="xint" value="0"/>
</config>
<config key="column_type">
<config key="collection_element_type">
<entry key="cell_class" type="xstring" value="org.knime.core.data.def.StringCell"/>
</config>
<entry key="cell_class" type="xstring" value="org.knime.core.data.collection.ListCell"/>
</config>
<config key="column_domain"/>
<config key="column_properties"/>
</config>
<config key="column_spec_8">
<entry key="column_name" type="xstring" value="FixVersion"/>
<config key="element_names">
<entry key="array-size" type="xint" value="0"/>
</config>
<config key="column_type">
<config key="collection_element_type">
<entry key="cell_class" type="xstring" value="org.knime.core.data.def.StringCell"/>
</config>
<entry key="cell_class" type="xstring" value="org.knime.core.data.collection.ListCell"/>
</config>
<config key="column_domain"/>
<config key="column_properties"/>
</config>
<config key="column_spec_9">
<entry key="column_name" type="xstring" value="Priority"/>
<config key="element_names">
<entry key="array-size" type="xint" value="0"/>
</config>
<config key="column_type">
<entry key="cell_class" type="xstring" value="org.knime.core.data.def.StringCell"/>
</config>
<config key="column_domain">
<config key="possible_values">
<entry key="array-size" type="xint" value="4"/>
<config key="0">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="MAJOR"/>
</config>
</config>
<config key="1">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="MINOR"/>
</config>
</config>
<config key="2">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="CRITICAL"/>
</config>
</config>
<config key="3">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="BLOCKER"/>
</config>
</config>
</config>
</config>
<config key="column_properties"/>
</config>
<config key="column_spec_10">
<entry key="column_name" type="xstring" value="Summary"/>
<config key="element_names">
<entry key="array-size" type="xint" value="0"/>
</config>
<config key="column_type">
<entry key="cell_class" type="xstring" value="org.knime.core.data.def.StringCell"/>
</config>
<config key="column_domain">
<config key="possible_values">
<entry key="array-size" type="xint" value="42"/>
<config key="0">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="RandomDataImpl.nextInt does not distribute uniformly for negative lower bound"/>
</config>
</config>
<config key="1">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="BitStreamGenerators (MersenneTwister, Well generators) do not clear normal deviate cache on setSeed"/>
</config>
</config>
<config key="2">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="Strange deprecations in API"/>
</config>
</config>
<config key="3">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="Cumulative probability and inverse cumulative probability inconsistencies"/>
</config>
</config>
<config key="4">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="ValueServer not deterministic for a fixed random number seed"/>
</config>
</config>
<config key="5">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="AbstractRandomGenerator nextInt() and nextLong() default implementations generate only positive values"/>
</config>
</config>
<config key="6">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="Complex Add and Subtract handle NaN arguments differently, but javadoc contracts are the same"/>
</config>
</config>
<config key="7">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="Weighted Mean evaluation may not have optimal numerics"/>
</config>
</config>
<config key="8">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="Exceptions in genetics package or not consistent with the rest of [math]"/>
</config>
</config>
<config key="9">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="MathUtils round method should propagate rather than wrap Runitme exceptions"/>
</config>
</config>
<config key="10">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="AbstractIntegerDistribution.inverseCumulativeProbability(...) Bug"/>
</config>
</config>
<config key="11">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="The static field ChiSquareTestImpl.distribution serves no purpose"/>
</config>
</config>
<config key="12">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="TestUtils is thread-hostile"/>
</config>
</config>
<config key="13">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="events detection in ODE solvers is too complex and not robust"/>
</config>
</config>
<config key="14">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="MathUtils.equals(double x, double y) disagrees with Javadoc"/>
</config>
</config>
<config key="15">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="Incorrect matrix rank via SVD"/>
</config>
</config>
<config key="16">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="LegendreGaussIntegrator ignores defaultMaximalIterationCount and does 38 million iterations"/>
</config>
</config>
<config key="17">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="RealVector Javadoc refers to non-existent package org.apache.commons.math.analysis.function"/>
</config>
</config>
<config key="18">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="SimplexSolver returns unfeasible solution"/>
</config>
</config>
<config key="19">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="KMeansPlusPlusClusterer breaks by division by zero"/>
</config>
</config>
<config key="20">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="restarting an ODE solver that has been stopped by an event doesn't work"/>
</config>
</config>
<config key="21">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="ConvergenceException in NormalDistributionImpl.cumulativeProbability()"/>
</config>
</config>
<config key="22">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="Multiple Regression newSampleData methods inconsistently create / omit intercepts"/>
</config>
</config>
<config key="23">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="Multiple Regression API should allow specification of whether or not to estimate intercept term"/>
</config>
</config>
<config key="24">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="GLSMultipleLinearRegression has no nontrivial validation tests"/>
</config>
</config>
<config key="25">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="Documentation improvements for multiple regression classes"/>
</config>
</config>
<config key="26">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="Wrong weight handling in Levenberg-Marquardt"/>
</config>
</config>
<config key="27">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="Inconsistent result from Levenberg-Marquardt"/>
</config>
</config>
<config key="28">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="Confusing interface for &quot;LevenbergMarquardtOptimizer&quot;"/>
</config>
</config>
<config key="29">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="Bugs in &quot;BrentOptimizer&quot;"/>
</config>
</config>
<config key="30">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="calculateYVariance in OLS/GLSMultipleLinearRegression uses residuals not Y vars"/>
</config>
</config>
<config key="31">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="Inconsistent behaviour of constructors in ArrayRealVector class"/>
</config>
</config>
<config key="32">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="Simplex Solver is very inaccurate on a large problem, even a very low value for epsilon"/>
</config>
</config>
<config key="33">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="Need to (re)initialize dYdY0 for multiple integrate with FirstOrderIntegratorWithJacobians"/>
</config>
</config>
<config key="34">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="weight versus sigma in AbstractLeastSquares"/>
</config>
</config>
<config key="35">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="StatUtils.sum returns NaN for zero-length arrays"/>
</config>
</config>
<config key="36">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException"/>
</config>
</config>
<config key="37">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="OpenMapRealVector.getSparcity should be getSparsity"/>
</config>
</config>
<config key="38">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="AbstractRealVector.sparseIterator fails when vector has exactly one non-zero entry"/>
</config>
</config>
<config key="39">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="Issue with &quot;SmoothingBicubicSplineInterpolator&quot;"/>
</config>
</config>
<config key="40">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="LevenbergMarquardtOptimizer ignores the VectorialConvergenceChecker parameter passed to it"/>
</config>
</config>
<config key="41">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="SimplexSolver not working as expected 2"/>
</config>
</config>
</config>
</config>
<config key="column_properties"/>
</config>
<config key="column_spec_11">
<entry key="column_name" type="xstring" value="Link"/>
<config key="element_names">
<entry key="array-size" type="xint" value="0"/>
</config>
<config key="column_type">
<entry key="cell_class" type="xstring" value="org.knime.core.data.def.StringCell"/>
</config>
<config key="column_domain">
<config key="possible_values">
<entry key="array-size" type="xint" value="42"/>
<config key="0">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="https://issues.apache.org/jira/browse/MATH-724"/>
</config>
</config>
<config key="1">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="https://issues.apache.org/jira/browse/MATH-723"/>
</config>
</config>
<config key="2">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="https://issues.apache.org/jira/browse/MATH-719"/>
</config>
</config>
<config key="3">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="https://issues.apache.org/jira/browse/MATH-692"/>
</config>
</config>
<config key="4">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="https://issues.apache.org/jira/browse/MATH-654"/>
</config>
</config>
<config key="5">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="https://issues.apache.org/jira/browse/MATH-640"/>
</config>
</config>
<config key="6">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="https://issues.apache.org/jira/browse/MATH-618"/>
</config>
</config>
<config key="7">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="https://issues.apache.org/jira/browse/MATH-588"/>
</config>
</config>
<config key="8">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="https://issues.apache.org/jira/browse/MATH-575"/>
</config>
</config>
<config key="9">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="https://issues.apache.org/jira/browse/MATH-555"/>
</config>
</config>
<config key="10">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="https://issues.apache.org/jira/browse/MATH-540"/>
</config>
</config>
<config key="11">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="https://issues.apache.org/jira/browse/MATH-506"/>
</config>
</config>
<config key="12">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="https://issues.apache.org/jira/browse/MATH-505"/>
</config>
</config>
<config key="13">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="https://issues.apache.org/jira/browse/MATH-484"/>
</config>
</config>
<config key="14">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="https://issues.apache.org/jira/browse/MATH-481"/>
</config>
</config>
<config key="15">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="https://issues.apache.org/jira/browse/MATH-465"/>
</config>
</config>
<config key="16">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="https://issues.apache.org/jira/browse/MATH-464"/>
</config>
</config>
<config key="17">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="https://issues.apache.org/jira/browse/MATH-453"/>
</config>
</config>
<config key="18">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="https://issues.apache.org/jira/browse/MATH-434"/>
</config>
</config>
<config key="19">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="https://issues.apache.org/jira/browse/MATH-429"/>
</config>
</config>
<config key="20">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="https://issues.apache.org/jira/browse/MATH-421"/>
</config>
</config>
<config key="21">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="https://issues.apache.org/jira/browse/MATH-414"/>
</config>
</config>
<config key="22">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="https://issues.apache.org/jira/browse/MATH-411"/>
</config>
</config>
<config key="23">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="https://issues.apache.org/jira/browse/MATH-409"/>
</config>
</config>
<config key="24">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="https://issues.apache.org/jira/browse/MATH-408"/>
</config>
</config>
<config key="25">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="https://issues.apache.org/jira/browse/MATH-407"/>
</config>
</config>
<config key="26">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="https://issues.apache.org/jira/browse/MATH-406"/>
</config>
</config>
<config key="27">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="https://issues.apache.org/jira/browse/MATH-405"/>
</config>
</config>
<config key="28">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="https://issues.apache.org/jira/browse/MATH-404"/>
</config>
</config>
<config key="29">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="https://issues.apache.org/jira/browse/MATH-395"/>
</config>
</config>
<config key="30">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="https://issues.apache.org/jira/browse/MATH-392"/>
</config>
</config>
<config key="31">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="https://issues.apache.org/jira/browse/MATH-391"/>
</config>
</config>
<config key="32">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="https://issues.apache.org/jira/browse/MATH-390"/>
</config>
</config>
<config key="33">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="https://issues.apache.org/jira/browse/MATH-380"/>
</config>
</config>
<config key="34">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="https://issues.apache.org/jira/browse/MATH-377"/>
</config>
</config>
<config key="35">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="https://issues.apache.org/jira/browse/MATH-373"/>
</config>
</config>
<config key="36">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="https://issues.apache.org/jira/browse/MATH-369"/>
</config>
</config>
<config key="37">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="https://issues.apache.org/jira/browse/MATH-368"/>
</config>
</config>
<config key="38">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="https://issues.apache.org/jira/browse/MATH-367"/>
</config>
</config>
<config key="39">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="https://issues.apache.org/jira/browse/MATH-365"/>
</config>
</config>
<config key="40">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="https://issues.apache.org/jira/browse/MATH-362"/>
</config>
</config>
<config key="41">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="https://issues.apache.org/jira/browse/MATH-288"/>
</config>
</config>
</config>
</config>
<config key="column_properties"/>
</config>
<config key="column_spec_12">
<entry key="column_name" type="xstring" value="Description"/>
<config key="element_names">
<entry key="array-size" type="xint" value="0"/>
</config>
<config key="column_type">
<entry key="cell_class" type="xstring" value="org.knime.core.data.def.StringCell"/>
</config>
<config key="column_domain">
<config key="possible_values">
<entry key="array-size" type="xint" value="42"/>
<config key="0">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="&lt;p&gt;When using the RandomDataImpl.nextInt function to get a uniform sample in a &lt;span class=&quot;error&quot;&gt;&amp;#91;lower, upper&amp;#93;&lt;/span&gt; interval, when the lower value is less than zero, the output is not uniformly distributed, as the lowest value is practically never returned.&lt;/p&gt;%%00010%%00010&lt;p&gt;See the attached NextIntUniformTest.java file. It uses a &lt;span class=&quot;error&quot;&gt;&amp;#91;-3, 5&amp;#93;&lt;/span&gt; interval. For several values between 0 and 1, testNextIntUniform1 prints the return value of RandomDataImpl.nextInt (as double and as int). We see that -2 through 5 are returned several times. The -3 value however, is only returned for 0.0, and is thus under-respresented in the integer samples. The output of test method testNextIntUniform2 also clearly shows that value -3 is never sampled.&lt;/p&gt;"/>
</config>
</config>
<config key="1">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="&lt;p&gt;The BitStream generators generate normal deviates (for nextGaussian) in pairs, caching the last value generated. When reseeded, the cache should be cleared; otherwise seeding two generators with the same value is not guaranteed to generate the same sequence.&lt;/p&gt;"/>
</config>
</config>
<config key="2">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="&lt;p&gt;Sorry if this doesn't belong here. I couldn't find any sort of mailing list or other feedback mechanism on the website.&lt;/p&gt;%%00010%%00010&lt;p&gt;RealMatrix has some very odd deprecations. In particular inverse(), getDeterminant() and isSingular(). The last has the message:&lt;/p&gt;%%00010%%00010&lt;blockquote&gt;&lt;p&gt;Deprecated. as of release 2.0, replaced by the boolean negation of new LUDecompositionImpl(m).getSolver().isNonSingular()&lt;/p&gt;&lt;/blockquote&gt;%%00010%%00010&lt;p&gt;That's an implementation, not an interface. The whole point of having an interface is that &lt;/p&gt;%%00010&lt;ul&gt;%%00010%%00009&lt;li&gt;I can query whether a matrix is singular withou having to know about LUDecompositions&lt;/li&gt;%%00010%%00009&lt;li&gt;You guys can change the implementation of isSingular() if something better pops up without us guys having to change our code.&lt;/li&gt;%%00010&lt;/ul&gt;%%00010%%00010%%00010&lt;p&gt;I'm not using these methods now, because they're deprecated, but I've basically recreated them in as static methods in a utility class. Wouldn't it be much better to just put code from the deprecation message into the method and remove the deprecation?&lt;/p&gt;"/>
</config>
</config>
<config key="3">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="&lt;p&gt;There are some inconsistencies in the documentation and implementation of functions regarding cumulative probabilities and inverse cumulative probabilities. More precisely, '&amp;lt;' and '&amp;lt;=' are not used in a consistent way.&lt;/p&gt;%%00010%%00010&lt;p&gt;Besides I would move the function inverseCumulativeProbability(double) to the interface Distribution. A true inverse of the distribution function does neither exist for Distribution nor for ContinuosDistribution. Thus we need to define the inverse in terms of quantiles anyway, and this can already be done for Distribution.&lt;/p&gt;%%00010%%00010&lt;p&gt;On the whole I would declare the (inverse) cumulative probability functions in the basic distribution interfaces as follows:&lt;/p&gt;%%00010%%00010&lt;p&gt;Distribution:&lt;/p&gt;%%00010&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;%%00010%%00009&lt;li&gt;cumulativeProbability(double x): returns P(X &amp;lt;= x)&lt;/li&gt;%%00010%%00009&lt;li&gt;cumulativeProbability(double x0, double x1): returns P(x0 &amp;lt; X &amp;lt;= x1) &lt;span class=&quot;error&quot;&gt;&amp;#91;see also 1)&amp;#93;&lt;/span&gt;&lt;/li&gt;%%00010%%00009&lt;li&gt;inverseCumulativeProbability(double p):&lt;br/&gt;%%00010  returns the quantile function inf{x in R | P(X&amp;lt;=x) &amp;gt;= p} &lt;span class=&quot;error&quot;&gt;&amp;#91;see also 2), 3), and 4)&amp;#93;&lt;/span&gt;&lt;/li&gt;%%00010&lt;/ul&gt;%%00010%%00010%%00010&lt;p&gt;1) An aternative definition could be P(x0 &amp;lt;= X &amp;lt;= x1). But this requires to put the function probability(double x) or another cumulative probability function into the interface Distribution in order be able to calculate P(x0 &amp;lt;= X &amp;lt;= x1) in AbstractDistribution.&lt;br/&gt;%%000102) This definition is stricter than the definition in ContinuousDistribution, because the definition there does not specify what to do if there are multiple x satisfying P(X&amp;lt;=x) = p.&lt;br/&gt;%%000103) A modification could be defined for p=0: Returning sup{x in R | P(X&amp;lt;=x) = 0} would yield the infimum of the distribution's support instead of a mandatory -infinity.&lt;br/&gt;%%000104) This affects issue &lt;a href=&quot;https://issues.apache.org/jira/browse/MATH-540&quot; title=&quot;AbstractIntegerDistribution.inverseCumulativeProbability(...) Bug&quot;&gt;&lt;del&gt;MATH-540&lt;/del&gt;&lt;/a&gt;. I'd prefere the definition from above for the following reasons:&lt;/p&gt;%%00010&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;%%00010%%00009&lt;li&gt;This definition simplifies inverse transform sampling (as mentioned in the other issue).&lt;/li&gt;%%00010%%00009&lt;li&gt;It is the standard textbook definition for the quantile function.&lt;/li&gt;%%00010%%00009&lt;li&gt;For integer distributions it has the advantage that the result doesn't change when switching to &quot;x in Z&quot;, i.e. the result is independent of considering the intergers as sole set or as part of the reals.&lt;/li&gt;%%00010&lt;/ul&gt;%%00010%%00010%%00010&lt;p&gt;ContinuousDistribution:&lt;br/&gt;%%00010nothing to be added regarding (inverse) cumulative probability functions&lt;/p&gt;%%00010%%00010&lt;p&gt;IntegerDistribution:&lt;/p&gt;%%00010&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;%%00010%%00009&lt;li&gt;cumulativeProbability(int x): returns P(X &amp;lt;= x)&lt;/li&gt;%%00010%%00009&lt;li&gt;cumulativeProbability(int x0, int x1): returns P(x0 &amp;lt; X &amp;lt;= x1) &lt;span class=&quot;error&quot;&gt;&amp;#91;see also 1) above&amp;#93;&lt;/span&gt;&lt;/li&gt;%%00010&lt;/ul&gt;"/>
</config>
</config>
<config key="4">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="&lt;p&gt;I have built an agent-based model using the Apache Commons Math library, which has come in handy.&lt;/p&gt;%%00010%%00010&lt;p&gt;The ValueServer seemed particularly helpful, as explained at:&lt;br/&gt;%%00010&lt;a href=&quot;http://commons.apache.org/math/userguide/random.html&quot;&gt;http://commons.apache.org/math/userguide/random.html&lt;/a&gt;&lt;/p&gt;%%00010%%00010&lt;p&gt;My simulation needs repeatable randomness, so I used this form of the ValueServer constructor:&lt;/p&gt;%%00010%%00010&lt;p&gt;    ValueServer(RandomData randomData) &lt;br/&gt;%%00010    Construct a ValueServer instance using a RandomData as its source of random data.&lt;br/&gt;%%00010    // &lt;a href=&quot;http://commons.apache.org/math/api-2.2/org/apache/commons/math/random/ValueServer.html&quot;&gt;http://commons.apache.org/math/api-2.2/org/apache/commons/math/random/ValueServer.html&lt;/a&gt;&lt;/p&gt;%%00010%%00010&lt;p&gt;However, in my simulation, I found that the ValueServer did not act deterministically if I supplied the same random number seed.&lt;/p&gt;%%00010%%00010&lt;p&gt;I have not inspected the source code, but I suspect that the ValueServer is not using the `randomData` generator correctly. If it was, then it should be deterministic.&lt;/p&gt;"/>
</config>
</config>
<config key="5">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="&lt;p&gt;The javadoc for these methods (and what is specified in the RandomGenerator interface) says that all int / long values should be in the range of these methods.  The default implementations provided in this class do not generate negative values.&lt;/p&gt;"/>
</config>
</config>
<config key="6">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="&lt;p&gt;For both Complex add and subtract, the javadoc states that&lt;/p&gt;%%00010%%00010&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;%%00010&lt;pre class=&quot;code-java&quot;&gt;* If either &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; or &amp;lt;code&amp;gt;rhs&amp;lt;/code&amp;gt; has a NaN value in either part,%%00010     * {@link #NaN} is returned; otherwise Inifinite and NaN values are%%00010     * returned in the parts of the result according to the rules &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt;%%00010     * {@link java.lang.&lt;span class=&quot;code-object&quot;&gt;Double&lt;/span&gt;} arithmetic&lt;/pre&gt;%%00010&lt;/div&gt;&lt;/div&gt;%%00010%%00010&lt;p&gt;Subtract includes an isNaN test and returns Complex.NaN if either complex argument isNaN; but add omits this test.  The test should be added to the add implementation (actually restored, since this looks like a code merge problem going back to 1.1).&lt;/p&gt;"/>
</config>
</config>
<config key="7">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="&lt;p&gt;I recently got this in a test run&lt;/p&gt;%%00010&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;%%00010&lt;pre class=&quot;code-java&quot;&gt;testWeightedConsistency(org.apache.commons.math.stat.descriptive.moment.MeanTest)  Time elapsed: 0 sec  &amp;lt;&amp;lt;&amp;lt; FAILURE!%%00010java.lang.AssertionError: expected:&amp;lt;0.002282165958997601&amp;gt; but was:&amp;lt;0.002282165958997157&amp;gt;%%00010%%00009at org.junit.Assert.fail(Assert.java:91)%%00010%%00009at org.junit.Assert.failNotEquals(Assert.java:645)%%00010%%00009at org.junit.Assert.assertEquals(Assert.java:441)%%00010%%00009at org.apache.commons.math.TestUtils.assertRelativelyEquals(TestUtils.java:178)%%00010%%00009at org.apache.commons.math.TestUtils.assertRelativelyEquals(TestUtils.java:153)%%00010%%00009at org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest.testWeightedConsistency(UnivariateStatisticAbstractTest.java:170)&lt;/pre&gt;%%00010&lt;/div&gt;&lt;/div&gt;%%00010%%00010&lt;p&gt;The correction formula used to compute the unweighted mean may not be appropriate or optimal in the presence of weights:&lt;/p&gt;%%00010%%00010&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;%%00010&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-comment&quot;&gt;// Compute initial estimate using definitional formula%%00010&lt;/span&gt;&lt;span class=&quot;code-object&quot;&gt;double&lt;/span&gt; sumw = sum.evaluate(weights,begin,length);%%00010&lt;span class=&quot;code-object&quot;&gt;double&lt;/span&gt; xbarw = sum.evaluate(values, weights, begin, length) / sumw;%%00010%%00010&lt;span class=&quot;code-comment&quot;&gt;// Compute correction factor in second pass%%00010&lt;/span&gt;&lt;span class=&quot;code-object&quot;&gt;double&lt;/span&gt; correction = 0;%%00010&lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; i = begin; i &amp;lt; begin + length; i++) {%%00010  correction += weights[i] * (values[i] - xbarw);%%00010}%%00010&lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; xbarw + (correction/sumw);&lt;/pre&gt;%%00010&lt;/div&gt;&lt;/div&gt;"/>
</config>
</config>
<config key="8">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="&lt;p&gt;InvalidRepresentationException is checked and non-localized.  This exception should be placed in the &lt;span class=&quot;error&quot;&gt;&amp;#91;math&amp;#93;&lt;/span&gt; hierarchy.  The AbstractListChromosome constructor also throws a non-localised IAE, which should be replaced by an appropriate &lt;span class=&quot;error&quot;&gt;&amp;#91;math&amp;#93;&lt;/span&gt; exception.&lt;/p&gt;"/>
</config>
</config>
<config key="9">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="&lt;p&gt;MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.&lt;/p&gt;"/>
</config>
</config>
<config key="10">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="&lt;p&gt;The AbstractIntegerDistribution.inverseCumulativeProbability(...) function attempts to decrement the lower bound of discrete distributions to values that go below the lower bound.&lt;/p&gt;"/>
</config>
</config>
<config key="11">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="&lt;p&gt;The static field ChiSquareTestImpl.distribution serves no purpose.&lt;/p&gt;%%00010%%00010&lt;p&gt;There is a setter for it, but in every case where the field is used, it is first overwritten with a new value.&lt;/p&gt;%%00010%%00010&lt;p&gt;The field and the setter should be removed, and the methods that create a new instance should create a local variable instead.&lt;/p&gt;%%00010%%00010&lt;p&gt;For Math 2.1, the field can be removed and the setter deprecated.&lt;/p&gt;"/>
</config>
</config>
<config key="12">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="&lt;p&gt;TestUtils has several mutable static fields which are not synchronised, or volatile.&lt;/p&gt;%%00010%%00010&lt;p&gt;If one of the fields is updated by thread A, there is no guarantee that thread B will see the full update - it may see a partially updated object.&lt;/p&gt;%%00010%%00010&lt;p&gt;Furthermore, at least some of the static fields reference a mutable object, which can be changed whilst another thread is using it.&lt;/p&gt;%%00010%%00010&lt;p&gt;As far as I can tell, this class must only ever be used by a single thread otherwise the results will be unpredictable.&lt;/p&gt;"/>
</config>
</config>
<config key="13">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="&lt;p&gt;All ODE solvers support multiple events detection since a long time. Events are specified by users by implementing the EventHandler interface. Events occur when the g(t, y) function evaluates to 0. When an event occurs, the solver step is shortened to make sure the event is located at the end of the step, and the event is triggered by calling the eventOccurred method in the user defined implementation class. Depending on the return value of this method, integration can continue, it can be stopped, or the state vector can be reset.&lt;/p&gt;%%00010%%00010&lt;p&gt;Some ODE solvers are adaptive step size solvers. They can modify step size to match an integration error setting, increasing step size when error is low (thus reducing computing costs) or reducing step size when error is high (thus fulfilling accuracy requirements).&lt;/p&gt;%%00010%%00010&lt;p&gt;The step adaptations due to events on one side and due to adaptive step size solvers are quite intricate by now, due to numerous fixes (&lt;a href=&quot;https://issues.apache.org/jira/browse/MATH-161&quot; title=&quot;patch for Mantissa&quot;&gt;&lt;del&gt;MATH-161&lt;/del&gt;&lt;/a&gt;, &lt;a href=&quot;https://issues.apache.org/jira/browse/MATH-213&quot; title=&quot;FirstOrderIntegrator.integrate does not give back integration stop time when an event handler stops integration&quot;&gt;&lt;del&gt;MATH-213&lt;/del&gt;&lt;/a&gt;, &lt;a href=&quot;https://issues.apache.org/jira/browse/MATH-322&quot; title=&quot;during ODE integration, the last event in a pair of very close event may not be detected&quot;&gt;&lt;del&gt;MATH-322&lt;/del&gt;&lt;/a&gt;, &lt;a href=&quot;https://issues.apache.org/jira/browse/MATH-358&quot; title=&quot;ODE integrator goes past specified end of integration range&quot;&gt;&lt;del&gt;MATH-358&lt;/del&gt;&lt;/a&gt;, &lt;a href=&quot;https://issues.apache.org/jira/browse/MATH-421&quot; title=&quot;restarting an ODE solver that has been stopped by an event doesn&amp;#39;t work&quot;&gt;&lt;del&gt;MATH-421&lt;/del&gt;&lt;/a&gt; and also during standard maintenance - see for example r781157). The code is very difficult to maintain. It seems each bug fix introduces new bugs (r781157/&lt;a href=&quot;https://issues.apache.org/jira/browse/MATH-322&quot; title=&quot;during ODE integration, the last event in a pair of very close event may not be detected&quot;&gt;&lt;del&gt;MATH-322&lt;/del&gt;&lt;/a&gt;) or tighten the link between adaptive step size and event detection (&lt;a href=&quot;https://issues.apache.org/jira/browse/MATH-388&quot; title=&quot;ODE integrator: different size needed for state vector and tolerance error vector dimension&quot;&gt;&lt;del&gt;MATH-388&lt;/del&gt;&lt;/a&gt;/r927202).&lt;/p&gt;%%00010%%00010&lt;p&gt;A new bug discovered recently on an external library using a slightly modified version of this code could not be retroffitted into commons-math, despite the same problem is present. At the beginning of EventState.evaluateStep, the initial step may be exactly 0 thus preventing root solving, but preventing this size to drop to 0 would reopen &lt;a href=&quot;https://issues.apache.org/jira/browse/MATH-388&quot; title=&quot;ODE integrator: different size needed for state vector and tolerance error vector dimension&quot;&gt;&lt;del&gt;MATH-388&lt;/del&gt;&lt;/a&gt;. I could not fix both bugs at the same time.&lt;/p&gt;%%00010%%00010&lt;p&gt;So it is now time to untangle events detection and adaptive step size, simplify code, and remove some inefficiency (event root solving is always done twice, once before step truncation and another time after truncation, of course with slightly different results, events shortened steps induce high computation load until the integrator recovers its optimal pace again, steps are rejected even when the event does not requires it ...).&lt;/p&gt;"/>
</config>
</config>
<config key="14">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="&lt;p&gt;MathUtils.equals(double x, double y) disagrees with Javadoc.&lt;/p&gt;%%00010%%00010&lt;p&gt;The Javadoc says:&lt;/p&gt;%%00010%%00010&lt;p&gt;Returns true iff they are equal as defined by  {@link #equals(double,double,int)}&lt;/p&gt;%%00010%%00010&lt;p&gt;However, the code actually uses == and checks for NaN:&lt;/p&gt;%%00010%%00010&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;%%00010&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; equals(&lt;span class=&quot;code-object&quot;&gt;double&lt;/span&gt; x, &lt;span class=&quot;code-object&quot;&gt;double&lt;/span&gt; y) {%%00010    &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; (&lt;span class=&quot;code-object&quot;&gt;Double&lt;/span&gt;.isNaN(x) &amp;amp;&amp;amp; &lt;span class=&quot;code-object&quot;&gt;Double&lt;/span&gt;.isNaN(y)) || x == y;%%00010}&lt;/pre&gt;%%00010&lt;/div&gt;&lt;/div&gt;%%00010%%00010&lt;p&gt;The method is deprecated, but it should probably still be consistent with its documentation.&lt;/p&gt;"/>
</config>
</config>
<config key="15">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="&lt;p&gt;The getRank() function of SingularValueDecompositionImpl does not work properly. This problem is probably related to the numerical stability problems mentioned in &lt;a href=&quot;https://issues.apache.org/jira/browse/MATH-327&quot;&gt;MATH-327&lt;/a&gt; and &lt;a href=&quot;https://issues.apache.org/jira/browse/MATH-320&quot;&gt;MATH-320&lt;/a&gt;.&lt;/p&gt;%%00010%%00010&lt;p&gt;Example call with the standard matrix from R (rank 2):&lt;/p&gt;%%00010%%00010&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeHeader panelHeader&quot; style=&quot;border-bottom-width: 1px;&quot;&gt;&lt;b&gt;TestSVDRank.java&lt;/b&gt;&lt;/div&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;%%00010&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-keyword&quot;&gt;import&lt;/span&gt; org.apache.commons.math.linear.Array2DRowRealMatrix;%%00010&lt;span class=&quot;code-keyword&quot;&gt;import&lt;/span&gt; org.apache.commons.math.linear.RealMatrix;%%00010&lt;span class=&quot;code-keyword&quot;&gt;import&lt;/span&gt; org.apache.commons.math.linear.SingularValueDecomposition;%%00010&lt;span class=&quot;code-keyword&quot;&gt;import&lt;/span&gt; org.apache.commons.math.linear.SingularValueDecompositionImpl;%%00010%%00010&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; class TestSVDRank {%%00010%%00009&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;static&lt;/span&gt; void main(&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;[] args) {%%00010%%00009%%00009&lt;span class=&quot;code-object&quot;&gt;double&lt;/span&gt;[][] d = { { 1, 1, 1 }, { 0, 0, 0 }, { 1, 2, 3 } };%%00010%%00009%%00009RealMatrix m = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; Array2DRowRealMatrix(d);%%00010%%00009%%00009SingularValueDecomposition svd = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; SingularValueDecompositionImpl(m);%%00010%%00009%%00009&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; r = svd.getRank();%%00010%%00009%%00009&lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.out.println(&lt;span class=&quot;code-quote&quot;&gt;&quot;Rank: &quot;&lt;/span&gt;+r);%%00010%%00009}%%00010}&lt;/pre&gt;%%00010&lt;/div&gt;&lt;/div&gt; %%00010%%00010&lt;p&gt;The rank is computed as 3. This problem also occurs for larger matrices. I discovered the problem when trying to replace the corresponding JAMA method.&lt;/p&gt;"/>
</config>
</config>
<config key="16">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="&lt;p&gt;The following code results in count = 37801710 which is effectively an infinite loop for typical functions we are using&lt;br/&gt;%%00010(in GeoGebra)&lt;/p&gt;%%00010%%00010&lt;p&gt;The argument defaultMaximalIterationCount = 100 is being ignored&lt;/p&gt;%%00010%%00010&lt;p&gt;This is the version we are using:&lt;br/&gt;%%00010&lt;a href=&quot;http://www.geogebra.org/trac/browser/trunk/geogebra/org/apache/commons/math/analysis/integration/LegendreGaussIntegrator.java&quot;&gt;http://www.geogebra.org/trac/browser/trunk/geogebra/org/apache/commons/math/analysis/integration/LegendreGaussIntegrator.java&lt;/a&gt;&lt;/p&gt;%%00010%%00010&lt;p&gt;    %%00009LegendreGaussIntegrator gauss = new LegendreGaussIntegrator(5, 100);&lt;/p&gt;%%00010%%00010&lt;p&gt;%%00009try {%%00010%%00009%%00009double result = gauss.integrate(new testFun(), -10, 0.32462367623786328);%%00010%%00009} catch (Exception ee) {%%00010%%00009%%00009ee.printStackTrace();%%00010%%00009}&lt;/p&gt;%%00010%%00010%%00010%%00010&lt;p&gt;class testFun implements UnivariateRealFunction {&lt;/p&gt;%%00010%%00010&lt;p&gt;    public double value(double x) throws FunctionEvaluationException {%%00010    %%00009count ++;%%00010        if (x&amp;gt;=0 &amp;amp;&amp;amp; x&amp;lt;=5) return 0.2; else return 0;%%00010    }&lt;/p&gt;%%00010%%00010&lt;p&gt;}&lt;/p&gt;"/>
</config>
</config>
<config key="17">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="&lt;p&gt;RealVector Javadoc refers to non-existent package org.apache.commons.math.analysis.function.&lt;/p&gt;%%00010%%00010&lt;p&gt;As this explains how to recode deprecated method calls, it ought to be corrected before release.&lt;/p&gt;"/>
</config>
</config>
<config key="18">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="&lt;p&gt;The SimplexSolver is returning an unfeasible solution:&lt;/p&gt;%%00010%%00010&lt;p&gt;import java.util.ArrayList;&lt;br/&gt;%%00010import java.text.DecimalFormat;&lt;br/&gt;%%00010import org.apache.commons.math.linear.ArrayRealVector;&lt;br/&gt;%%00010import org.apache.commons.math.optimization.GoalType;&lt;br/&gt;%%00010import org.apache.commons.math.optimization.OptimizationException;&lt;br/&gt;%%00010import org.apache.commons.math.optimization.linear.*;&lt;/p&gt;%%00010%%00010&lt;p&gt;public class SimplexSolverBug {&lt;/p&gt;%%00010%%00010&lt;p&gt;    public static void main(String[] args) throws OptimizationException {&lt;/p&gt;%%00010%%00010&lt;p&gt;        LinearObjectiveFunction c = new LinearObjectiveFunction(new double[]{0.0d, 1.0d, 1.0d, 0.0d, 0.0d, 0.0d, 0.0d}, 0.0d);&lt;/p&gt;%%00010%%00010&lt;p&gt;        ArrayList&amp;lt;LinearConstraint&amp;gt; cnsts = new ArrayList&amp;lt;LinearConstraint&amp;gt;(5);&lt;br/&gt;%%00010        LinearConstraint cnst;&lt;br/&gt;%%00010        cnst = new LinearConstraint(new double[] {1.0d, -0.1d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d}, Relationship.EQ, -0.1d);&lt;br/&gt;%%00010        cnsts.add(cnst);&lt;br/&gt;%%00010        cnst = new LinearConstraint(new double[] {1.0d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d}, Relationship.GEQ, -1e-18d);&lt;br/&gt;%%00010        cnsts.add(cnst);&lt;br/&gt;%%00010        cnst = new LinearConstraint(new double[] {0.0d, 1.0d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d}, Relationship.GEQ, 0.0d);&lt;br/&gt;%%00010        cnsts.add(cnst);&lt;br/&gt;%%00010        cnst = new LinearConstraint(new double[] {0.0d, 0.0d, 0.0d, 1.0d, 0.0d, -0.0128588d, 1e-5d}, Relationship.EQ, 0.0d);&lt;br/&gt;%%00010        cnsts.add(cnst);&lt;br/&gt;%%00010        cnst = new LinearConstraint(new double[] {0.0d, 0.0d, 0.0d, 0.0d, 1.0d, 1e-5d, -0.0128586d}, Relationship.EQ, 1e-10d);&lt;br/&gt;%%00010        cnsts.add(cnst);&lt;br/&gt;%%00010        cnst = new LinearConstraint(new double[] {0.0d, 0.0d, 1.0d, -1.0d, 0.0d, 0.0d, 0.0d}, Relationship.GEQ, 0.0d);&lt;br/&gt;%%00010        cnsts.add(cnst);&lt;br/&gt;%%00010        cnst = new LinearConstraint(new double[] {0.0d, 0.0d, 1.0d, 1.0d, 0.0d, 0.0d, 0.0d}, Relationship.GEQ, 0.0d);&lt;br/&gt;%%00010        cnsts.add(cnst);&lt;br/&gt;%%00010        cnst = new LinearConstraint(new double[] {0.0d, 0.0d, 1.0d, 0.0d, -1.0d, 0.0d, 0.0d}, Relationship.GEQ, 0.0d);&lt;br/&gt;%%00010        cnsts.add(cnst);&lt;br/&gt;%%00010        cnst = new LinearConstraint(new double[] {0.0d, 0.0d, 1.0d, 0.0d, 1.0d, 0.0d, 0.0d}, Relationship.GEQ, 0.0d);&lt;br/&gt;%%00010        cnsts.add(cnst);&lt;/p&gt;%%00010%%00010&lt;p&gt;        DecimalFormat df = new java.text.DecimalFormat(&quot;0.#####E0&quot;);&lt;/p&gt;%%00010%%00010&lt;p&gt;        System.out.println(&quot;Constraints:&quot;);&lt;br/&gt;%%00010        for(LinearConstraint con : cnsts) {%%00010            for (int i = 0; i &amp;lt; con.getCoefficients().getDimension(); ++i)%%00010                System.out.print(df.format(con.getCoefficients().getData()[i]) + &quot; &quot;);%%00010            System.out.println(con.getRelationship() + &quot; &quot; + con.getValue());%%00010        }&lt;/p&gt;%%00010%%00010&lt;p&gt;        SimplexSolver simplex = new SimplexSolver(1e-7);&lt;br/&gt;%%00010        double[] sol = simplex.optimize(c, cnsts, GoalType.MINIMIZE, false).getPointRef();&lt;br/&gt;%%00010        System.out.println(&quot;Solution:\n&quot; + new ArrayRealVector(sol));&lt;br/&gt;%%00010        System.out.println(&quot;Second constraint is violated!&quot;);&lt;br/&gt;%%00010    }&lt;br/&gt;%%00010}&lt;/p&gt;%%00010%%00010%%00010&lt;p&gt;It's an odd problem, but something I ran across.  I tracked the problem to the getPivotRow routine in SimplexSolver.  It was choosing a pivot that resulted in a negative right-hand-side.  I recommend a fix by replacing&lt;br/&gt;%%00010                ...&lt;br/&gt;%%00010                if (MathUtils.equals(ratio, minRatio, epsilon)) {&lt;br/&gt;%%00010                ...&lt;br/&gt;%%00010with&lt;br/&gt;%%00010                ...&lt;br/&gt;%%00010                if (MathUtils.equals(ratio, minRatio, Math.abs(epsilon/entry))) {&lt;br/&gt;%%00010                ...&lt;/p&gt;%%00010%%00010&lt;p&gt;I believe this would be more appropriate (and at least resolves this particular problem).&lt;/p&gt;%%00010%%00010&lt;p&gt;Also, you may want to consider making a change in getPivotColumn to replace&lt;br/&gt;%%00010            ...&lt;br/&gt;%%00010            if (MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) &amp;lt; 0) {&lt;br/&gt;%%00010            ...&lt;br/&gt;%%00010with&lt;br/&gt;%%00010            ...&lt;br/&gt;%%00010            if (tableau.getEntry(0, i) &amp;lt; minValue) &lt;br/&gt;%%00010            ...&lt;br/&gt;%%00010because I don't see the point of biasing earlier columns when multiple entries are within epsilon of each other.  Why not pick the absolute smallest.  I don't know that any problem can result from doing it the other way, but the latter may be a safer bet.&lt;/p&gt;%%00010%%00010&lt;p&gt;VERY IMPORTANT: I discovered another bug that occurs when not restricting to non-negatives.  In SimplexTableu::getSolution(), &lt;br/&gt;%%00010          ...          &lt;br/&gt;%%00010          if (basicRows.contains(basicRow)) &lt;br/&gt;%%00010              // if multiple variables can take a given value&lt;br/&gt;%%00010              // then we choose the first and set the rest equal to 0&lt;br/&gt;%%00010              coefficients&lt;span class=&quot;error&quot;&gt;&amp;#91;i&amp;#93;&lt;/span&gt; = 0;&lt;br/&gt;%%00010          ...&lt;br/&gt;%%00010should be&lt;br/&gt;%%00010          ...          &lt;br/&gt;%%00010          if (basicRows.contains(basicRow)) {&lt;br/&gt;%%00010              // if multiple variables can take a given value&lt;br/&gt;%%00010              // then we choose the first and set the rest equal to 0&lt;br/&gt;%%00010              coefficients&lt;span class=&quot;error&quot;&gt;&amp;#91;i&amp;#93;&lt;/span&gt; = (restrictToNonNegative ? 0 : -mostNegative);&lt;br/&gt;%%00010          ...&lt;br/&gt;%%00010If necessary, I can give an example of where this bug causes a problem, but it should be fairly obvious why this was wrong.&lt;/p&gt;"/>
</config>
</config>
<config key="19">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="&lt;p&gt;For a certain space, KMeansPlusPlusClusterer  breaks. This is a blocker because this space occurs in our domain. &lt;/p&gt;"/>
</config>
</config>
<config key="20">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="&lt;p&gt;If an ODE solver is setup with an EventHandler that return STOP when the even is triggered, the integrators stops (which is exactly the expected behavior).&lt;br/&gt;%%00010If however the user want to restart the solver from the final state reached at the event with the same configuration (expecting the event to be triggered again at a later time), then the integrator may fail to start. It can get stuck at the previous event.&lt;/p&gt;%%00010%%00010&lt;p&gt;The occurrence of the bug depends on the residual sign of the g function which is not exactly 0, it depends on the convergence of the first event.&lt;/p&gt;%%00010%%00010&lt;p&gt;As this use case is fairly general, event occurring less than epsilon after the solver start in the first step should be ignored, where epsilon is the convergence threshold of the event. The sign of the g function should be evaluated after this initial ignore zone, not exactly at beginning (if there are no event at the very beginning g(t0) and g(t0+epsilon) have the same sign, so this does not hurt ; if there is an event at the very beginning, g(t0) and g(t0+epsilon) have opposite signs and we want to start with the second one. Of course, the sign of epsilon depend on the integration direction (forward or backward).&lt;/p&gt;"/>
</config>
</config>
<config key="21">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="&lt;p&gt;I get a ConvergenceException in  NormalDistributionImpl.cumulativeProbability() for very large/small parameters including Infinity, -Infinity.&lt;br/&gt;%%00010For instance in the following code:&lt;/p&gt;%%00010%%00010&lt;p&gt;%%00009@Test&lt;br/&gt;%%00010%%00009public void testCumulative() {&lt;br/&gt;%%00010%%00009%%00009final NormalDistribution nd = new NormalDistributionImpl();&lt;br/&gt;%%00010%%00009%%00009for (int i = 0; i &amp;lt; 500; i++) {&lt;br/&gt;%%00010%%00009%%00009%%00009final double val = Math.exp&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/information.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;;&lt;br/&gt;%%00010%%00009%%00009%%00009try {%%00010%%00009%%00009%%00009%%00009System.out.println(&quot;val = &quot; + val + &quot; cumulative = &quot; + nd.cumulativeProbability(val));%%00010%%00009%%00009%%00009} catch (MathException e) {%%00010%%00009%%00009%%00009%%00009e.printStackTrace();%%00010%%00009%%00009%%00009%%00009fail();%%00010%%00009%%00009%%00009}&lt;br/&gt;%%00010%%00009%%00009}&lt;br/&gt;%%00010%%00009}&lt;/p&gt;%%00010%%00010&lt;p&gt;In version 2.0, I get no exception. &lt;/p&gt;%%00010%%00010&lt;p&gt;My suggestion is to change in the implementation of cumulativeProbability(double) to catch all ConvergenceException (and return for very large and very small values), not just MaxIterationsExceededException.&lt;/p&gt;"/>
</config>
</config>
<config key="22">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="&lt;p&gt;The newSampleData(double[], nrows, ncols) method used in the unit tests adds a unitary column to the design matrix, resulting in an intercept term being estimated among the regression parameters.  The other newSampleData methods do not do this, forcing users to add the column of &quot;1&quot;s to estimate models with intercept.  Behavior should be consistent and users should not have to add the column.&lt;/p&gt;"/>
</config>
</config>
<config key="23">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="&lt;p&gt;The OLS and GLS regression APIs should support estimating models including intercepts using design matrices including only variable data.&lt;/p&gt;"/>
</config>
</config>
<config key="24">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="&lt;p&gt;There are no non-trivial tests verifying the computations for GLSMultipleLinearRegression.  Tests verifying computations against analytically determined models, R or some other reference package / datasets should be added to ensure that the statistics reported by this class are valid.&lt;/p&gt;"/>
</config>
</config>
<config key="25">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="&lt;p&gt;The user guide examples showing how to set up and estimate linear models using OLS and GLS multiple regression need to be updated to reflect changes in the API.  The javadoc for these classes and user guide descriptions also need to be improved to make it clear how to estimate a model with an intercept term.&lt;/p&gt;"/>
</config>
</config>
<config key="26">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="&lt;p&gt;A comparison with a Fortran version of Levenberg-Marquardt reveals that when observations have different weights, the 2.1 version reaches a value of the function which does not necessary correspond to the minimum&lt;/p&gt;"/>
</config>
</config>
<config key="27">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="&lt;p&gt;Levenberg-Marquardt (its method doOptimize) returns a VectorialPointValuePair.  However, the class holds the optimum point, the vector of the objective function, the cost and residuals.  The value returns by doOptimize does not always corresponds to the point which leads to the residuals and cost&lt;/p&gt;"/>
</config>
</config>
<config key="28">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="&lt;p&gt;&lt;tt&gt;LevenbergMarquardtOptimizer&lt;/tt&gt; inherits from &lt;tt&gt;AbstractLeastSquaresOptimizer&lt;/tt&gt; which in turn implements &lt;tt&gt;DifferentiableMultivariateVectorialOptimizer&lt;/tt&gt;. That interface mandates methods for setting and getting a &lt;tt&gt;VectorialConvergenceChecker&lt;/tt&gt;.&lt;br/&gt;%%00010In v2.1, however, that checker is never used! The convergence check is performed using parameters specific to the Levenberg-Marquardt algorithm. Such circumvention of the superclass interface is confusing and leads to totally unexpected behaviour (such as changing the values of the thresholds of the &lt;tt&gt;VectorialConvergenceChecker&lt;/tt&gt; being ineffective).&lt;br/&gt;%%00010In the development version, the default constructor of &lt;tt&gt;LevenbergMarquardtOptimizer&lt;/tt&gt; sets the the &lt;tt&gt;VectorialConvergenceChecker&lt;/tt&gt; field to &quot;null&quot; and when such is the case, the behaviour is as in v2.1. Although it is documented, this is still confusing since it is impossible to use &lt;tt&gt;LevenbergMarquardtOptimizer&lt;/tt&gt; through its &lt;tt&gt;DifferentiableMultivariateVectorialOptimizer&lt;/tt&gt; interface: When using the &lt;tt&gt;VectorialConvergenceChecker&lt;/tt&gt;, one does not know what parameters to use in order to reproduce the results obtained with the LM-specific convergence check (i.e. how to reproduce the result from v2.1).&lt;br/&gt;%%00010Unless I'm missing something, I think that there should be an LM-specific implementation of &lt;tt&gt;VectorialConvergenceChecker&lt;/tt&gt; that, when given the usual relative and absolute thresholds, can perform a check that will give the same result as the currently specific check (when the &quot;checker&quot; field is &quot;null&quot;).&lt;/p&gt;"/>
</config>
</config>
<config key="29">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="&lt;p&gt;I apologize for having provided a buggy implementation of Brent's optimization algorithm (class &quot;BrentOptimizer&quot; in package &quot;optimization.univariate&quot;).&lt;br/&gt;%%00010The unit tests didn't show that there was something wrong, although (from the &quot;changes.xml&quot; file) I discovered that, at the time, Luc had noticed something weird in the implementation's behaviour.&lt;br/&gt;%%00010Comparing with an implementation in Python, I could figure out the fixes. I'll modify &quot;BrentOptimizer&quot; and add a test. I also propose to change the name of the unit test class from &quot;BrentMinimizerTest&quot; to &quot;BrentOptimizerTest&quot;.&lt;/p&gt;"/>
</config>
</config>
<config key="30">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="&lt;p&gt;Implementation of OLS/GLSMultipleLinearRegression is:&lt;br/&gt;%%00010@Override&lt;br/&gt;%%00010173        protected double calculateYVariance() {%%00010174            RealVector residuals = calculateResiduals();%%00010175            return residuals.dotProduct(residuals) /%%00010176                   (X.getRowDimension() - X.getColumnDimension());%%00010177        }&lt;/p&gt;%%00010%%00010&lt;p&gt;This gives variance of residuals not variance of the dependent (Y) variable as the documentation suggests.&lt;/p&gt;"/>
</config>
</config>
<config key="31">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="&lt;p&gt;ArrayRealVector(double[] d) allows to construct a zero-length vector, but ArrayRealVector(double[] d, boolean copyArray) doesn't. Both should allow this as zero-length vectors are mathematically well-defined objects and they are useful boundary cases in many algorithms.&lt;/p&gt;%%00010%%00010&lt;p&gt;This breaks some arithmetic operators (addition) on zero-length real vectors which worked in 2.0 but don't work in 2.1&lt;/p&gt;"/>
</config>
</config>
<config key="32">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="&lt;p&gt;I'm currently playing with a program for solving a rather simple chess puzzle. The goal is to place 12 knights on a 8x8 board, such that each field is either attacked by a knight, or contains a knight. To solve this problem (and different variants) I want to use a handcrafted Branch and Bound algorithm that uses Linear Programming to calculate an upperbound on the number of fields that can be covered by a certain amount of knights.&lt;/p&gt;%%00010%%00010&lt;p&gt;The idea is to create variables for each field that has to be covered, and to create variables for each field to contain a knight. A cover variable can only become positive if a corresponding knight variable for an adjacent field is also positive, there is a limit to the amount of knights we may place (so the sum of all knight variables cannot be larger than 12) and the cover variables cannot be larger than one. Also, only the cover variables have a coefficient of one in the objective function, all other variables have zero. Because we want to cover the entire board our goal will be to maximize the objective function, since we want to maximize the number of fields that are covered.&lt;/p&gt;%%00010%%00010&lt;p&gt;Since a basic chessboard has 64 fields and since it is possible to cover the chessboard with 12 knights, we know there is an integer solution that has value 64. Since we are solving a relaxed variant of the problem, the value should be at least 64. However, when I use the Simplex Solver, I get a value of around 58.6, which is much too low. Even when I relax the constraints in such a fashion that 64 knights may be placed on the board, the solution value remains the same. I've lowered the value of epsilon as much as I can and it still gives the incorrect value. What makes it worse is that the calculation is totally useless as an upperbound (if the value would have been around 70, it would have been an upperbound at least).&lt;/p&gt;%%00010%%00010&lt;p&gt;I've heard that using the revised simplex method is a lot better with respect to stacked errors, so I am not sure this is really a bug, or just a problem that arises when the two phase simplex method is used for large problems.&lt;/p&gt;%%00010%%00010&lt;p&gt;I will try to attach a code example that implements the problem (but possibly isn't that readable).&lt;/p&gt;"/>
</config>
</config>
<config key="33">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="&lt;p&gt;There is a lack in the method integrate of FirstOrderIntegratorWithJacobians. The jacobian DYDY0 can't be initialized by the user, unlike DFDP with DF0DP.&lt;br/&gt;%%00010So, for several successive integrations, the matrix is reinitialized to identity and that is not what we might want.&lt;/p&gt;"/>
</config>
</config>
<config key="34">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="&lt;p&gt;In AbstractLeastSquares, residualsWeights contains the WEIGHTS assigned to each observation.  In the method getRMS(), these weights are multiplicative as they should. unlike in getChiSquare() where it appears at the denominator!   If the weight is really the weight of the observation, it should multiply the square of the residual even in the computation of the chi2.&lt;/p&gt;%%00010%%00010&lt;p&gt; Once corrected, getRMS() can even reduce&lt;/p&gt;%%00010%%00010&lt;p&gt; public double getRMS() {return Math.sqrt(getChiSquare()/rows);}&lt;/p&gt;"/>
</config>
</config>
<config key="35">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="&lt;p&gt;StatUtils.sum returns NaN for zero-length arrays, which is:&lt;/p&gt;%%00010%%00010&lt;p&gt;1. inconsistent with the mathematical notion of sum: in maths, sum_{i=0}^{N-1} a_i will be 0 for N=0. In particular, the identity&lt;br/&gt;%%00010&lt;br/&gt;%%00010sum_{i=0}^{k-1} a_i + sum_{i=k}^{N-1} = sum_{i=0}^{N-1}&lt;/p&gt;%%00010%%00010&lt;p&gt;is broken for k = 0, since NaN + x = NaN, not x.&lt;/p&gt;%%00010%%00010&lt;p&gt;2. introduces hard to debug erros (returning a NaN is one of the worst forms of reporting an exceptional condition, as NaNs propagate silently and require manual tracing during the debugging)&lt;/p&gt;%%00010%%00010&lt;p&gt;3. enforces &quot;special case&quot; handling when the user expects that the summed array can have a zero length.&lt;/p&gt;%%00010%%00010&lt;p&gt;The correct behaviour is, in my opinion, to return 0.0, not NaN in the above case.&lt;/p&gt;"/>
</config>
</config>
<config key="36">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="&lt;p&gt;Method &lt;/p&gt;%%00010%%00010&lt;p&gt;    BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial)  &lt;/p&gt;%%00010%%00010&lt;p&gt;invokes &lt;/p&gt;%%00010%%00010&lt;p&gt;    BisectionSolver.solve(double min, double max) &lt;/p&gt;%%00010%%00010&lt;p&gt;which throws NullPointerException, as member variable&lt;/p&gt;%%00010%%00010&lt;p&gt;    UnivariateRealSolverImpl.f &lt;/p&gt;%%00010%%00010&lt;p&gt;is null.&lt;/p&gt;%%00010%%00010&lt;p&gt;Instead the method:&lt;/p&gt;%%00010%%00010&lt;p&gt;    BisectionSolver.solve(final UnivariateRealFunction f, double min, double max)&lt;/p&gt;%%00010%%00010&lt;p&gt;should be called.&lt;/p&gt;%%00010%%00010&lt;p&gt;Steps to reproduce:&lt;/p&gt;%%00010%%00010&lt;p&gt;invoke:&lt;/p&gt;%%00010%%00010&lt;p&gt;     new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5);&lt;/p&gt;%%00010%%00010&lt;p&gt;NullPointerException will be thrown.&lt;/p&gt;"/>
</config>
</config>
<config key="37">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="&lt;p&gt;The term for describing the ratio of nonzero elements to zero elements in a matrix/vector is sparsity, not sparcity.  Suggest renaming getSparcity() to getSparsity()&lt;/p&gt;"/>
</config>
</config>
<config key="38">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="&lt;p&gt;The following program:&lt;br/&gt;%%00010===&lt;br/&gt;%%00010import java.util.Iterator;&lt;br/&gt;%%00010import org.apache.commons.math.linear.*;&lt;/p&gt;%%00010%%00010&lt;p&gt;public class SparseIteratorTester&lt;br/&gt;%%00010{&lt;br/&gt;%%00010    public static void main(String[] args) {&lt;br/&gt;%%00010        double vdata[] = { 0.0, 1.0, 0.0 };&lt;br/&gt;%%00010        RealVector v = new ArrayRealVector(vdata);&lt;br/&gt;%%00010        Iterator&amp;lt;RealVector.Entry&amp;gt; iter = v.sparseIterator();&lt;br/&gt;%%00010        while(iter.hasNext()) {%%00010            RealVector.Entry entry = iter.next();%%00010            System.out.printf(&quot;%d: %f\n&quot;, entry.getIndex(), entry.getValue());%%00010        }   &lt;br/&gt;%%00010    }       &lt;br/&gt;%%00010} &lt;br/&gt;%%00010===&lt;br/&gt;%%00010generates this output:&lt;/p&gt;%%00010%%00010&lt;p&gt;1: 1.000000&lt;br/&gt;%%00010Exception in thread &quot;main&quot; java.lang.ArrayIndexOutOfBoundsException: -1&lt;br/&gt;%%00010%%00009at org.apache.commons.math.linear.ArrayRealVector.getEntry(ArrayRealVector.java:995)&lt;br/&gt;%%00010%%00009at org.apache.commons.math.linear.AbstractRealVector$EntryImpl.getValue(AbstractRealVector.java:850)&lt;br/&gt;%%00010%%00009at test.SparseIteratorTester.main(SparseIteratorTester.java:13)&lt;br/&gt;%%00010===&lt;/p&gt;%%00010%%00010&lt;p&gt;This patch fixes it, and simplifies AbstractRealVector.SparseEntryIterator  (sorry, i don't see any form entry for attaching a file)&lt;br/&gt;%%00010===&lt;br/&gt;%%00010Index: src/main/java/org/apache/commons/math/linear/AbstractRealVector.java&lt;br/&gt;%%00010===================================================================&lt;br/&gt;%%00010&amp;#8212; src/main/java/org/apache/commons/math/linear/AbstractRealVector.java%%00009(revision 936985)&lt;br/&gt;%%00010+++ src/main/java/org/apache/commons/math/linear/AbstractRealVector.java%%00009(working copy)&lt;br/&gt;%%00010@@ -18,6 +18,7 @@&lt;br/&gt;%%00010 package org.apache.commons.math.linear;&lt;/p&gt;%%00010%%00010&lt;p&gt; import java.util.Iterator;&lt;br/&gt;%%00010+import java.util.NoSuchElementException;&lt;/p&gt;%%00010%%00010&lt;p&gt; import org.apache.commons.math.FunctionEvaluationException;&lt;br/&gt;%%00010 import org.apache.commons.math.MathRuntimeException;&lt;br/&gt;%%00010@@ -875,40 +876,25 @@&lt;br/&gt;%%00010         /** Dimension of the vector. */&lt;br/&gt;%%00010         private final int dim;&lt;/p&gt;%%00010%%00010&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;%%00010%%00009&lt;li&gt;/** Temporary entry (reused on each call to {@link #next()}. */&lt;/li&gt;%%00010%%00009&lt;li&gt;private EntryImpl tmp = new EntryImpl();&lt;br/&gt;%%00010-&lt;/li&gt;%%00010%%00009&lt;li&gt;/** Current entry. */&lt;br/&gt;%%00010+        /** Last entry returned by #next(). */&lt;br/&gt;%%00010         private EntryImpl current;&lt;/li&gt;%%00010&lt;/ul&gt;%%00010%%00010%%00010&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;%%00010%%00009&lt;li&gt;/** Next entry. */&lt;br/&gt;%%00010+        /** Next entry for #next() to return. */&lt;br/&gt;%%00010         private EntryImpl next;&lt;/li&gt;%%00010&lt;/ul&gt;%%00010%%00010%%00010&lt;p&gt;         /** Simple constructor. */&lt;br/&gt;%%00010         protected SparseEntryIterator() {&lt;br/&gt;%%00010             dim = getDimension();&lt;br/&gt;%%00010             current = new EntryImpl();&lt;/p&gt;%%00010&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;%%00010%%00009&lt;li&gt;if (current.getValue() == 0) {%%00010-                advance(current);%%00010-            }&lt;/li&gt;%%00010%%00009&lt;li&gt;if(current.getIndex() &amp;gt;= 0){%%00010-                // There is at least one non-zero entry%%00010-                next = new EntryImpl();%%00010-                next.setIndex(current.getIndex());%%00010+            next = new EntryImpl();%%00010+            if(next.getValue() == 0)%%00010                 advance(next);%%00010-            } else {%%00010-                // The vector consists of only zero entries, so deny having a next%%00010-                current = null;%%00010-            }&lt;br/&gt;%%00010         }&lt;/li&gt;%%00010&lt;/ul&gt;%%00010%%00010%%00010&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;%%00010%%00009&lt;li&gt;/** Advance an entry up to the next non null one.&lt;br/&gt;%%00010+        /** Advance an entry up to the next nonzero value.&lt;/li&gt;%%00010&lt;/ul&gt;%%00010&lt;ul&gt;%%00010%%00009&lt;li&gt;@param e entry to advance&lt;br/&gt;%%00010          */&lt;br/&gt;%%00010         protected void advance(EntryImpl e) {&lt;/li&gt;%%00010&lt;/ul&gt;%%00010&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;%%00010%%00009&lt;li&gt;if (e == null) {%%00010-                return;%%00010-            }&lt;br/&gt;%%00010             do {%%00010                 e.setIndex(e.getIndex() + 1);%%00010             } while (e.getIndex() &amp;lt; dim &amp;amp;&amp;amp; e.getValue() == 0);&lt;br/&gt;%%00010@@ -919,22 +905,17 @@&lt;/li&gt;%%00010&lt;/ul&gt;%%00010%%00010%%00010&lt;p&gt;         /** {@inheritDoc} */&lt;br/&gt;%%00010         public boolean hasNext() {%%00010-            return current != null;%%00010+            return next.getIndex() &amp;gt;= 0;%%00010         }&lt;br/&gt;%%00010 &lt;br/&gt;%%00010         /** {@inheritDoc} */&lt;br/&gt;%%00010         public Entry next() {&lt;/p&gt;%%00010&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;%%00010%%00009&lt;li&gt;tmp.setIndex(current.getIndex());&lt;/li&gt;%%00010%%00009&lt;li&gt;if (next != null) {&lt;/li&gt;%%00010%%00009&lt;li&gt;current.setIndex(next.getIndex());&lt;/li&gt;%%00010%%00009&lt;li&gt;advance(next);&lt;/li&gt;%%00010%%00009&lt;li&gt;if (next.getIndex() &amp;lt; 0) {%%00010-                    next = null;%%00010-                }&lt;/li&gt;%%00010%%00009&lt;li&gt;} else {%%00010-                current = null;%%00010-            }&lt;/li&gt;%%00010%%00009&lt;li&gt;return tmp;&lt;br/&gt;%%00010+            int index = next.getIndex();&lt;br/&gt;%%00010+            if(index &amp;lt; 0)&lt;br/&gt;%%00010+                throw new NoSuchElementException();&lt;br/&gt;%%00010+            current.setIndex(index);&lt;br/&gt;%%00010+            advance(next);&lt;br/&gt;%%00010+            return current;&lt;br/&gt;%%00010         }&lt;/li&gt;%%00010&lt;/ul&gt;%%00010%%00010%%00010&lt;p&gt;         /** {@inheritDoc} */&lt;/p&gt;"/>
</config>
</config>
<config key="39">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="&lt;p&gt;I figured out that the name of this class is misleading as the implementation doesn't perform the intended smoothing.&lt;/p&gt;%%00010%%00010&lt;p&gt;In order to solve this issue, I propose to:&lt;/p&gt;%%00010&lt;ol&gt;%%00010%%00009&lt;li&gt;deprecate the &quot;SmoothingBicubicSplineInterpolator&quot; class&lt;/li&gt;%%00010%%00009&lt;li&gt;create a &quot;BicubicSplineInterpolator&quot; class (similar to the above class but with the useless code removed)&lt;/li&gt;%%00010%%00009&lt;li&gt;remove the &quot;SmoothingBicubicSplineInterpolatorTest&quot; class&lt;/li&gt;%%00010%%00009&lt;li&gt;add a &quot;BicubicSplineInterpolatorTest&quot; with essentially the same contents as the above one&lt;/li&gt;%%00010&lt;/ol&gt;%%00010%%00010%%00010&lt;p&gt;Then I would also add a new &quot;SmoothingPolynomialBicubicSplineInterpolator&quot; where I used the &quot;PolynomialFitter&quot; class to smooth the input data along both dimensions before the interpolating function is computed.&lt;/p&gt;%%00010%%00010&lt;p&gt;Does someone object to these changes?&lt;/p&gt;"/>
</config>
</config>
<config key="40">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="&lt;p&gt;LevenbergMarquardtOptimizer ignores the VectorialConvergenceChecker parameter passed to it. This makes it hard to specify custom stopping criteria for the optimizer.&lt;/p&gt;"/>
</config>
</config>
<config key="41">
<entry key="datacell" type="xstring" value="org.knime.core.data.def.StringCell"/>
<config key="org.knime.core.data.def.StringCell">
<entry key="StringCell" type="xstring" value="&lt;p&gt;SimplexSolver didn't find the optimal solution.&lt;/p&gt;%%00010%%00010&lt;p&gt;Program for Lpsolve:&lt;br/&gt;%%00010=====================&lt;br/&gt;%%00010/* Objective function */&lt;br/&gt;%%00010max: 7 a 3 b;&lt;/p&gt;%%00010%%00010&lt;p&gt;/* Constraints */&lt;br/&gt;%%00010R1: +3 a -5 c &amp;lt;= 0;&lt;br/&gt;%%00010R2: +2 a -5 d &amp;lt;= 0;&lt;br/&gt;%%00010R3: +2 b -5 c &amp;lt;= 0;&lt;br/&gt;%%00010R4: +3 b -5 d &amp;lt;= 0;&lt;br/&gt;%%00010R5: +3 a +2 b &amp;lt;= 5;&lt;br/&gt;%%00010R6: +2 a +3 b &amp;lt;= 5;&lt;/p&gt;%%00010%%00010&lt;p&gt;/* Variable bounds */&lt;br/&gt;%%00010a &amp;lt;= 1;&lt;br/&gt;%%00010b &amp;lt;= 1;&lt;br/&gt;%%00010=====================&lt;br/&gt;%%00010Results(correct): a = 1, b = 1, value = 10&lt;/p&gt;%%00010%%00010%%00010&lt;p&gt;Program for SimplexSolve:&lt;br/&gt;%%00010=====================&lt;br/&gt;%%00010LinearObjectiveFunction kritFcia = new LinearObjectiveFunction(new double[]{7, 3, 0, 0}, 0);&lt;br/&gt;%%00010Collection&amp;lt;LinearConstraint&amp;gt; podmienky = new ArrayList&amp;lt;LinearConstraint&amp;gt;();&lt;br/&gt;%%00010podmienky.add(new LinearConstraint(new double[]{1, 0, 0, 0}, Relationship.LEQ, 1));&lt;br/&gt;%%00010podmienky.add(new LinearConstraint(new double[]{0, 1, 0, 0}, Relationship.LEQ, 1));&lt;br/&gt;%%00010podmienky.add(new LinearConstraint(new double[]{3, 0, -5, 0}, Relationship.LEQ, 0));&lt;br/&gt;%%00010podmienky.add(new LinearConstraint(new double[]{2, 0, 0, -5}, Relationship.LEQ, 0));&lt;br/&gt;%%00010podmienky.add(new LinearConstraint(new double[]{0, 2, -5, 0}, Relationship.LEQ, 0));&lt;br/&gt;%%00010podmienky.add(new LinearConstraint(new double[]{0, 3, 0, -5}, Relationship.LEQ, 0));&lt;br/&gt;%%00010podmienky.add(new LinearConstraint(new double[]{3, 2, 0, 0}, Relationship.LEQ, 5));&lt;br/&gt;%%00010podmienky.add(new LinearConstraint(new double[]{2, 3, 0, 0}, Relationship.LEQ, 5));&lt;br/&gt;%%00010SimplexSolver solver = new SimplexSolver();&lt;br/&gt;%%00010RealPointValuePair result = solver.optimize(kritFcia, podmienky, GoalType.MAXIMIZE, true);&lt;br/&gt;%%00010=====================&lt;br/&gt;%%00010Results(incorrect): a = 1, b = 0.5, value = 8.5&lt;/p&gt;%%00010%%00010&lt;p&gt;P.S. I used the latest software from the repository (including &lt;a href=&quot;https://issues.apache.org/jira/browse/MATH-286&quot; title=&quot;SimplexSolver not working as expected?&quot;&gt;&lt;del&gt;MATH-286&lt;/del&gt;&lt;/a&gt; fix).&lt;/p&gt;"/>
</config>
</config>
</config>
</config>
<config key="column_properties"/>
</config>
<config key="column_spec_13">
<entry key="column_name" type="xstring" value="Comments"/>
<config key="element_names">
<entry key="array-size" type="xint" value="0"/>
</config>
<config key="column_type">
<config key="collection_element_type">
<entry key="cell_class" type="xstring" value="org.knime.core.data.def.StringCell"/>
</config>
<entry key="cell_class" type="xstring" value="org.knime.core.data.collection.ListCell"/>
</config>
<config key="column_domain"/>
<config key="column_properties"/>
</config>
</config>
