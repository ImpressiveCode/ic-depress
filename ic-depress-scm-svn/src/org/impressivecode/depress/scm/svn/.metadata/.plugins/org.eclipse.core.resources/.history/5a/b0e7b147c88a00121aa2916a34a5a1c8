package org.knime.mynode;

import java.io.File;
import java.io.IOException;

import org.knime.core.data.DataCell;
import org.knime.core.data.DataColumnSpec;
import org.knime.core.data.DataColumnSpecCreator;
import org.knime.core.data.DataRow;
import org.knime.core.data.DataTableSpec;
import org.knime.core.data.RowKey;
import org.knime.core.data.def.DefaultRow;
import org.knime.core.data.def.DoubleCell;
import org.knime.core.data.def.IntCell;
import org.knime.core.data.def.StringCell;
import org.knime.core.node.BufferedDataContainer;
import org.knime.core.node.BufferedDataTable;
import org.knime.core.node.CanceledExecutionException;
import org.knime.core.node.defaultnodesettings.SettingsModelIntegerBounded;
import org.knime.core.node.ExecutionContext;
import org.knime.core.node.ExecutionMonitor;
import org.knime.core.node.InvalidSettingsException;
import org.knime.core.node.NodeLogger;
import org.knime.core.node.NodeModel;
import org.knime.core.node.NodeSettingsRO;
import org.knime.core.node.NodeSettingsWO;

/**
 * This is the model implementation of MyNode01. KNIME
 * 
 * @author KNIME
 */
public class MyNode01NodeModel extends NodeModel {

	/**
	 * Constructor for the node model.
	 */
	protected MyNode01NodeModel() {

		// TODO one incoming port and one outgoing port is assumed
		super(1, 1);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected BufferedDataTable[] execute(final BufferedDataTable[] inData,
			final ExecutionContext exec) throws Exception {

		// TODO do something here
		MyNode01Logger.instance().info(
				"Node Model Stub... this is not yet implemented !");
		//
		//
		// // the data table spec of the single output table,
		// // the table will have three columns:
		// DataColumnSpec[] allColSpecs = new DataColumnSpec[3];
		// allColSpecs[0] =
		// new DataColumnSpecCreator("Column 0", StringCell.TYPE).createSpec();
		// allColSpecs[1] =
		// new DataColumnSpecCreator("Column 1", DoubleCell.TYPE).createSpec();
		// allColSpecs[2] =
		// new DataColumnSpecCreator("Column 2", IntCell.TYPE).createSpec();
		// DataTableSpec outputSpec = new DataTableSpec(allColSpecs);
		// // the execution context will provide us with storage capacity, in
		// this
		// // case a data container to which we will add rows sequentially
		// // Note, this container can also handle arbitrary big data tables, it
		// // will buffer to disc if necessary.
		// BufferedDataContainer container =
		// exec.createDataContainer(outputSpec);
		// // let's add m_count rows to it
		// for (int i = 0; i < m_count.getIntValue(); i++) {
		// RowKey key = new RowKey("Row " + i);
		// // the cells of the current row, the types of the cells must match
		// // the column spec (see above)
		// DataCell[] cells = new DataCell[3];
		// cells[0] = new StringCell("String_" + i);
		// cells[1] = new DoubleCell(0.5 * i);
		// cells[2] = new IntCell(i);
		// DataRow row = new DefaultRow(key, cells);
		// container.addRowToTable(row);
		//
		// // check if the execution monitor was canceled
		// exec.checkCanceled();
		// exec.setProgress(i / (double)m_count.getIntValue(),
		// "Adding row " + i);
		// }
		// // once we are done, we close the container and return its table
		// container.close();
		// BufferedDataTable out = container.getTable();
		return null;// new BufferedDataTable[]{out};
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected void reset() {

	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected DataTableSpec[] configure(final DataTableSpec[] inSpecs)
			throws InvalidSettingsException {

	    DataColumnSpec columnSpec = createOutputColumnSpec();

	    DataTableSpec appendedSpec = new DataTableSpec(newColumnSpec);
	    
	    DataTableSpec outputSpec = new DataTableSpec(inSpecs[IN_PORT],
	            appendedSpec);
	    
	    return new DataTableSpec[]{outputSpec};
	}

	private DataColumnSpec createOutputColumnSpec() {
        // we want to add a column with the number of the bin 
        DataColumnSpecCreator colSpecCreator = new DataColumnSpecCreator(
                "Bin Number", IntCell.TYPE);
        // if we know the number of bins we also know the number of possible
        // values of that new column
        DataColumnDomainCreator domainCreator = new DataColumnDomainCreator(
                new IntCell(0), new IntCell(m_numberOfBins.getIntValue() - 1));
        // and can add this domain information to the output spec
        colSpecCreator.setDomain(domainCreator.createDomain());
        // now the column spec can be created
        DataColumnSpec newColumnSpec = colSpecCreator.createSpec();
        return newColumnSpec;
    }
	
	/**
	 * {@inheritDoc}
	 */
	@Override
	protected void saveSettingsTo(final NodeSettingsWO settings) {
		MyNode01Settings.saveSettingsTo(settings);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected void loadValidatedSettingsFrom(final NodeSettingsRO settings)
			throws InvalidSettingsException {
		MyNode01Settings.loadSettingsFrom(settings);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected void validateSettings(final NodeSettingsRO settings)
			throws InvalidSettingsException {
		MyNode01Settings.validateSettings(settings);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected void loadInternals(final File internDir,
			final ExecutionMonitor exec) throws IOException,
			CanceledExecutionException {

		// TODO load internal data.
		// Everything handed to output ports is loaded automatically (data
		// returned by the execute method, models loaded in loadModelContent,
		// and user settings set through loadSettingsFrom - is all taken care
		// of). Load here only the other internals that need to be restored
		// (e.g. data used by the views).

	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected void saveInternals(final File internDir,
			final ExecutionMonitor exec) throws IOException,
			CanceledExecutionException {

		// TODO save internal models.
		// Everything written to output ports is saved automatically (data
		// returned by the execute method, models saved in the saveModelContent,
		// and user settings saved through saveSettingsTo - is all taken care
		// of). Save here only the other internals that need to be preserved
		// (e.g. data used by the views).

	}

}
